# USER PROFILE API SPECIFICATIONS v1.0
**Complete AI-Ready Build Specification**

---

## ðŸŽ¯ API OVERVIEW

**Purpose**: Manage complete user lifecycle including profiles, photos, interests, settings, subscriptions, and verification status.

**Technology Stack**:
- Framework: FastAPI (Python)
- Database: PostgreSQL (schema: `activity`)
- Authentication: JWT tokens from auth-api (Bearer token in Authorization header)
- External Dependencies: image-api (photo processing), email-api (notifications)
- Rate Limiting: Redis-based (slowapi)

**Core Principles**:
1. ALL database operations via stored procedures
2. NO direct SQL queries in API code
3. JWT token validation on protected endpoints
4. Subscription-level enforcement at API layer
5. Ghost mode and blocking logic handled by calling services

---

## ðŸ“Š DATABASE MAPPING

### Primary Tables

**activity.users** - Core user table
- Primary Key: `user_id` (UUID, uuidv7())
- Unique Keys: `email`, `username`
- Status Fields: `status` (active/temporary_ban/banned), `is_verified`, `is_active`
- Subscription: `subscription_level` (free/club/premium), `subscription_expires_at`
- Profile: `first_name`, `last_name`, `profile_description`, `date_of_birth`, `gender`
- Photos: `main_photo_url`, `main_photo_moderation_status`, `profile_photos_extra` (JSONB array)
- Counters: `activities_created_count`, `activities_attended_count`, `verification_count`, `no_show_count`
- Captain: `is_captain`, `captain_since`
- Timestamps: `created_at`, `updated_at`, `last_login_at`, `last_seen_at`

**activity.user_interests** - Interest tags (max 20 per user)
- Composite Primary Key: (`user_id`, `interest_tag`)
- Foreign Key: `user_id` â†’ activity.users
- Fields: `weight` (0.0-1.0), `created_at`, `updated_at`

**activity.user_settings** - User preferences
- Primary Key: `user_id` (1-to-1 with users)
- Foreign Key: `user_id` â†’ activity.users
- Notifications: `email_notifications`, `push_notifications`, `activity_reminders`, `community_updates`, `friend_requests`, `marketing_emails`
- Privacy: `ghost_mode` (Premium feature)
- Locale: `language`, `timezone`

**activity.media_assets** - Photo storage metadata
- Primary Key: `asset_id` (UUID)
- Foreign Key: `user_id` â†’ activity.users
- Fields: `asset_type`, `file_name`, `storage_url`, `thumbnail_url`, `mime_type`, `file_size_bytes`, `width`, `height`, `is_processed`

---

## ðŸ” AUTHENTICATION & AUTHORIZATION

### Token Structure (from auth-api)

**Access Token Claims**:
```json
{
  "sub": "user_id (UUID)",
  "email": "user@example.com",
  "org_id": "organization_id (UUID, optional)",
  "subscription_level": "free|club|premium",
  "ghost_mode": true|false,
  "exp": 1704067200,
  "iat": 1704066300,
  "type": "access"
}
```

**Token Validation**:
- Verify JWT signature (HS256)
- Check expiration (`exp` > current timestamp)
- Extract `user_id` from `sub` claim
- Extract `subscription_level` for feature gating
- Extract `ghost_mode` for privacy features

**Subscription Level Enforcement**:
- `free`: Basic profile, limited features
- `club`: Mid-tier features
- `premium`: All features including ghost_mode, see who favorited/viewed you

---

## ðŸ“‹ STORED PROCEDURES SPECIFICATION

### 1. sp_get_user_profile

**Purpose**: Retrieve complete user profile with interests and settings

**Parameters**:
- `p_user_id` UUID - User to retrieve
- `p_requesting_user_id` UUID - User making the request (for privacy checks)

**Returns**: Single row with columns:
- `user_id` UUID
- `email` VARCHAR(255)
- `username` VARCHAR(100)
- `first_name` VARCHAR(100)
- `last_name` VARCHAR(100)
- `profile_description` TEXT
- `main_photo_url` VARCHAR(500)
- `main_photo_moderation_status` photo_moderation_status
- `profile_photos_extra` JSONB (array of photo URLs)
- `date_of_birth` DATE
- `gender` VARCHAR(50)
- `subscription_level` subscription_level
- `subscription_expires_at` TIMESTAMP WITH TIME ZONE
- `is_captain` BOOLEAN
- `captain_since` TIMESTAMP WITH TIME ZONE
- `is_verified` BOOLEAN
- `verification_count` INT
- `no_show_count` INT
- `activities_created_count` INT
- `activities_attended_count` INT
- `created_at` TIMESTAMP WITH TIME ZONE
- `last_seen_at` TIMESTAMP WITH TIME ZONE
- `interests` JSONB (array of {tag, weight} objects)
- `settings` JSONB (user_settings as object)

**Logic**:
1. Check if `p_requesting_user_id` has blocked `p_user_id` â†’ return NULL if blocked
2. Check if `p_user_id` has blocked `p_requesting_user_id` â†’ return NULL if blocked
3. JOIN users table with user_interests (aggregate to JSONB)
4. LEFT JOIN user_settings (convert to JSONB)
5. Return complete profile

**Error Conditions**:
- User not found â†’ return NULL
- User blocked/blocking â†’ return NULL
- Invalid UUID â†’ raise exception

---

### 2. sp_update_user_profile

**Purpose**: Update user profile fields (name, description, dob, gender)

**Parameters**:
- `p_user_id` UUID - User to update
- `p_first_name` VARCHAR(100) - NULL to skip update
- `p_last_name` VARCHAR(100) - NULL to skip update
- `p_profile_description` TEXT - NULL to skip update
- `p_date_of_birth` DATE - NULL to skip update
- `p_gender` VARCHAR(50) - NULL to skip update

**Returns**: 
- `success` BOOLEAN
- `updated_at` TIMESTAMP WITH TIME ZONE

**Logic**:
1. Check user exists and is active
2. Update only non-NULL fields
3. Trigger `update_timestamp()` automatically
4. Return success status

**Error Conditions**:
- User not found â†’ return success=FALSE
- User banned â†’ raise exception
- Invalid date_of_birth (future date) â†’ raise exception

---

### 3. sp_update_username

**Purpose**: Change username (must be unique)

**Parameters**:
- `p_user_id` UUID
- `p_new_username` VARCHAR(100)

**Returns**: 
- `success` BOOLEAN
- `message` TEXT

**Logic**:
1. Validate username format (alphanumeric + underscore, 3-30 chars)
2. Check uniqueness in users table
3. Update username
4. Return success

**Error Conditions**:
- Username taken â†’ return success=FALSE, message="Username already taken"
- Invalid format â†’ raise exception
- User not found â†’ return success=FALSE

---

### 4. sp_set_main_photo

**Purpose**: Set main profile photo (triggers moderation)

**Parameters**:
- `p_user_id` UUID
- `p_photo_url` VARCHAR(500)

**Returns**: 
- `success` BOOLEAN
- `moderation_status` photo_moderation_status

**Logic**:
1. Update `main_photo_url` = p_photo_url
2. Set `main_photo_moderation_status` = 'pending'
3. Return success and status

**Error Conditions**:
- User not found â†’ return success=FALSE
- Invalid URL â†’ raise exception

**Notes**:
- Moderation happens externally (admin panel)
- Photo must show clear face (functional safety requirement)

---

### 5. sp_add_profile_photo

**Purpose**: Add photo to extra photos array (max 8 total)

**Parameters**:
- `p_user_id` UUID
- `p_photo_url` VARCHAR(500)

**Returns**: 
- `success` BOOLEAN
- `message` TEXT
- `photo_count` INT

**Logic**:
1. Get current `profile_photos_extra` JSONB array
2. Check array length < 8
3. Append new photo URL to array
4. Update `profile_photos_extra`
5. Return success and new count

**Error Conditions**:
- Max photos reached â†’ return success=FALSE, message="Maximum 8 photos allowed"
- User not found â†’ return success=FALSE
- Photo URL already exists â†’ return success=FALSE, message="Photo already added"

---

### 6. sp_remove_profile_photo

**Purpose**: Remove photo from extra photos array

**Parameters**:
- `p_user_id` UUID
- `p_photo_url` VARCHAR(500)

**Returns**: 
- `success` BOOLEAN
- `photo_count` INT

**Logic**:
1. Get current `profile_photos_extra` JSONB array
2. Remove photo URL from array (JSONB array operations)
3. Update `profile_photos_extra`
4. Return success and new count

**Error Conditions**:
- Photo not found in array â†’ return success=FALSE
- User not found â†’ return success=FALSE

---

### 7. sp_set_user_interests

**Purpose**: Set complete interest tags list (replaces existing)

**Parameters**:
- `p_user_id` UUID
- `p_interests` JSONB - Array of {tag: string, weight: float} objects (max 20)

**Returns**: 
- `success` BOOLEAN
- `interest_count` INT

**Logic**:
1. Validate JSONB structure and max 20 tags
2. DELETE all existing interests for user
3. INSERT new interests from JSONB array
4. Return success and count

**Error Conditions**:
- Invalid JSONB structure â†’ raise exception
- More than 20 tags â†’ return success=FALSE
- Invalid weight (not 0.0-1.0) â†’ raise exception
- User not found â†’ return success=FALSE

**Example Input**:
```json
[
  {"tag": "hiking", "weight": 1.0},
  {"tag": "photography", "weight": 0.8},
  {"tag": "coffee", "weight": 0.6}
]
```

---

### 8. sp_add_user_interest

**Purpose**: Add single interest tag

**Parameters**:
- `p_user_id` UUID
- `p_interest_tag` VARCHAR(100)
- `p_weight` DECIMAL(3,2) - Default 1.0

**Returns**: 
- `success` BOOLEAN
- `message` TEXT

**Logic**:
1. Count existing interests
2. Check count < 20
3. INSERT new interest (ON CONFLICT UPDATE weight)
4. Return success

**Error Conditions**:
- Max interests reached â†’ return success=FALSE, message="Maximum 20 interests allowed"
- Invalid weight â†’ raise exception
- User not found â†’ return success=FALSE

---

### 9. sp_remove_user_interest

**Purpose**: Remove single interest tag

**Parameters**:
- `p_user_id` UUID
- `p_interest_tag` VARCHAR(100)

**Returns**: 
- `success` BOOLEAN

**Logic**:
1. DELETE interest WHERE user_id AND interest_tag
2. Return success (TRUE even if not found)

**Error Conditions**:
- User not found â†’ return success=FALSE

---

### 10. sp_get_user_settings

**Purpose**: Retrieve user settings

**Parameters**:
- `p_user_id` UUID

**Returns**: Single row with columns:
- `email_notifications` BOOLEAN
- `push_notifications` BOOLEAN
- `activity_reminders` BOOLEAN
- `community_updates` BOOLEAN
- `friend_requests` BOOLEAN
- `marketing_emails` BOOLEAN
- `ghost_mode` BOOLEAN
- `language` VARCHAR(10)
- `timezone` VARCHAR(50)

**Logic**:
1. SELECT from user_settings WHERE user_id
2. If not exists, INSERT default settings first

**Error Conditions**:
- User not found â†’ raise exception

---

### 11. sp_update_user_settings

**Purpose**: Update user settings (partial update)

**Parameters**:
- `p_user_id` UUID
- `p_email_notifications` BOOLEAN - NULL to skip
- `p_push_notifications` BOOLEAN - NULL to skip
- `p_activity_reminders` BOOLEAN - NULL to skip
- `p_community_updates` BOOLEAN - NULL to skip
- `p_friend_requests` BOOLEAN - NULL to skip
- `p_marketing_emails` BOOLEAN - NULL to skip
- `p_ghost_mode` BOOLEAN - NULL to skip (Premium only)
- `p_language` VARCHAR(10) - NULL to skip
- `p_timezone` VARCHAR(50) - NULL to skip

**Returns**: 
- `success` BOOLEAN

**Logic**:
1. Check if settings exist, INSERT defaults if not
2. UPDATE only non-NULL fields
3. For `ghost_mode`: Check subscription_level = 'premium', raise exception if not
4. Return success

**Error Conditions**:
- User not found â†’ return success=FALSE
- Ghost mode requested but not Premium â†’ raise exception with message "Ghost mode requires Premium subscription"
- Invalid timezone â†’ raise exception

---

### 12. sp_update_subscription

**Purpose**: Update user subscription level

**Parameters**:
- `p_user_id` UUID
- `p_subscription_level` subscription_level (free/club/premium)
- `p_subscription_expires_at` TIMESTAMP WITH TIME ZONE - NULL for free, required for club/premium

**Returns**: 
- `success` BOOLEAN

**Logic**:
1. Validate: free requires NULL expiry, club/premium require expiry
2. UPDATE subscription_level and subscription_expires_at
3. If downgrading from premium: disable ghost_mode in user_settings
4. Return success

**Error Conditions**:
- Invalid level + expiry combination â†’ raise exception
- User not found â†’ return success=FALSE

**Notes**:
- Captains get free Premium (handled externally)

---

### 13. sp_set_captain_status

**Purpose**: Grant/revoke Captain program membership

**Parameters**:
- `p_user_id` UUID
- `p_is_captain` BOOLEAN

**Returns**: 
- `success` BOOLEAN

**Logic**:
1. If granting captain (TRUE):
   - Set `is_captain` = TRUE
   - Set `captain_since` = NOW()
   - Set `subscription_level` = 'premium'
   - Set `subscription_expires_at` = NOW() + INTERVAL '1 year'
2. If revoking captain (FALSE):
   - Set `is_captain` = FALSE
   - Set `captain_since` = NULL
   - Revert to `subscription_level` = 'free'
   - Set `subscription_expires_at` = NULL
3. Return success

**Error Conditions**:
- User not found â†’ return success=FALSE

**Notes**:
- Captain = free Premium subscription
- Only admins can call this

---

### 14. sp_increment_verification_count

**Purpose**: Increment verification count (called after peer verification)

**Parameters**:
- `p_user_id` UUID

**Returns**: 
- `new_count` INT

**Logic**:
1. UPDATE verification_count = verification_count + 1
2. Return new count

**Error Conditions**:
- User not found â†’ raise exception

---

### 15. sp_increment_no_show_count

**Purpose**: Increment no-show count (called after no-show report)

**Parameters**:
- `p_user_id` UUID

**Returns**: 
- `new_count` INT

**Logic**:
1. UPDATE no_show_count = no_show_count + 1
2. Return new count

**Error Conditions**:
- User not found â†’ raise exception

---

### 16. sp_update_activity_counts

**Purpose**: Update activity counters

**Parameters**:
- `p_user_id` UUID
- `p_created_delta` INT - Change in created count (can be negative)
- `p_attended_delta` INT - Change in attended count (can be negative)

**Returns**: 
- `new_created_count` INT
- `new_attended_count` INT

**Logic**:
1. UPDATE activities_created_count = activities_created_count + p_created_delta
2. UPDATE activities_attended_count = activities_attended_count + p_attended_delta
3. Ensure counts don't go below 0
4. Return new counts

**Error Conditions**:
- User not found â†’ raise exception
- Count would go negative â†’ raise exception

---

### 17. sp_update_last_seen

**Purpose**: Update last seen timestamp

**Parameters**:
- `p_user_id` UUID

**Returns**: 
- `success` BOOLEAN

**Logic**:
1. UPDATE last_seen_at = NOW()
2. Return success

**Error Conditions**:
- User not found â†’ return success=FALSE

**Notes**:
- Called periodically by client (e.g., every 5 minutes)

---

### 18. sp_search_users

**Purpose**: Search users by name or username

**Parameters**:
- `p_query` TEXT - Search term
- `p_requesting_user_id` UUID - User making request (for blocking filter)
- `p_limit` INT - Max results (default 20)
- `p_offset` INT - Pagination offset (default 0)

**Returns**: Array of rows:
- `user_id` UUID
- `username` VARCHAR(100)
- `first_name` VARCHAR(100)
- `last_name` VARCHAR(100)
- `main_photo_url` VARCHAR(500)
- `is_verified` BOOLEAN
- `verification_count` INT

**Logic**:
1. Search WHERE (username ILIKE '%query%' OR first_name ILIKE '%query%' OR last_name ILIKE '%query%')
2. Filter out users where blocking exists (either direction)
3. Filter out banned users (status != 'active')
4. ORDER BY verification_count DESC, username ASC
5. LIMIT and OFFSET
6. Return results

**Error Conditions**:
- Invalid limit/offset â†’ raise exception

---

### 19. sp_ban_user

**Purpose**: Ban user temporarily or permanently

**Parameters**:
- `p_user_id` UUID
- `p_ban_reason` TEXT
- `p_ban_expires_at` TIMESTAMP WITH TIME ZONE - NULL for permanent ban

**Returns**: 
- `success` BOOLEAN

**Logic**:
1. If `p_ban_expires_at` is NULL:
   - Set `status` = 'banned'
   - Set `ban_expires_at` = NULL
2. Else:
   - Set `status` = 'temporary_ban'
   - Set `ban_expires_at` = p_ban_expires_at
3. Set `ban_reason` = p_ban_reason
4. Return success

**Error Conditions**:
- User not found â†’ return success=FALSE
- Invalid expiry (past date) â†’ raise exception

**Notes**:
- Only admins can call this

---

### 20. sp_unban_user

**Purpose**: Remove ban from user

**Parameters**:
- `p_user_id` UUID

**Returns**: 
- `success` BOOLEAN

**Logic**:
1. Set `status` = 'active'
2. Set `ban_expires_at` = NULL
3. Set `ban_reason` = NULL
4. Return success

**Error Conditions**:
- User not found â†’ return success=FALSE

---

### 21. sp_moderate_main_photo

**Purpose**: Approve or reject main photo moderation

**Parameters**:
- `p_user_id` UUID
- `p_moderation_status` photo_moderation_status (approved/rejected)
- `p_moderator_user_id` UUID

**Returns**: 
- `success` BOOLEAN

**Logic**:
1. UPDATE main_photo_moderation_status = p_moderation_status
2. If rejected: Send email notification to user
3. Return success

**Error Conditions**:
- User not found â†’ return success=FALSE
- Invalid status (not approved/rejected) â†’ raise exception

**Notes**:
- Only moderators can call this

---

### 22. sp_get_pending_photo_moderations

**Purpose**: Get list of users with pending main photo moderation

**Parameters**:
- `p_limit` INT - Max results (default 50)
- `p_offset` INT - Pagination offset (default 0)

**Returns**: Array of rows:
- `user_id` UUID
- `username` VARCHAR(100)
- `email` VARCHAR(255)
- `main_photo_url` VARCHAR(500)
- `created_at` TIMESTAMP WITH TIME ZONE

**Logic**:
1. SELECT users WHERE main_photo_moderation_status = 'pending'
2. ORDER BY created_at ASC (oldest first)
3. LIMIT and OFFSET
4. Return results

**Error Conditions**:
- Invalid limit/offset â†’ raise exception

---

### 23. sp_delete_user_account

**Purpose**: Soft delete user account (for GDPR compliance)

**Parameters**:
- `p_user_id` UUID

**Returns**: 
- `success` BOOLEAN

**Logic**:
1. Anonymize user data:
   - Set email = 'deleted_' || user_id || '@deleted.local'
   - Set username = 'deleted_' || user_id
   - Set first_name = NULL
   - Set last_name = NULL
   - Set profile_description = NULL
   - Set main_photo_url = NULL
   - Set profile_photos_extra = '[]'
   - Set date_of_birth = NULL
2. Set status = 'banned'
3. DELETE user_interests, user_settings
4. Return success

**Error Conditions**:
- User not found â†’ return success=FALSE

**Notes**:
- This is a soft delete (preserves activity participation history)
- Hard delete would CASCADE through many tables

---

## ðŸŒ API ENDPOINTS SPECIFICATION

### BASE URL
`/api/v1/users`

All endpoints require `Authorization: Bearer <access_token>` unless specified otherwise.

---

## PROFILE MANAGEMENT

### GET /users/me
**Description**: Get current user's complete profile

**Authentication**: Required (JWT)

**Rate Limit**: 100/minute

**Request**:
- Headers: `Authorization: Bearer <token>`
- Body: None

**Response 200 OK**:
```json
{
  "user_id": "550e8400-e29b-41d4-a716-446655440000",
  "email": "user@example.com",
  "username": "johndoe",
  "first_name": "John",
  "last_name": "Doe",
  "profile_description": "Outdoor enthusiast and coffee lover",
  "main_photo_url": "https://cdn.example.com/photos/main.jpg",
  "main_photo_moderation_status": "approved",
  "profile_photos_extra": [
    "https://cdn.example.com/photos/1.jpg",
    "https://cdn.example.com/photos/2.jpg"
  ],
  "date_of_birth": "1990-05-15",
  "gender": "male",
  "subscription_level": "premium",
  "subscription_expires_at": "2025-12-31T23:59:59Z",
  "is_captain": false,
  "captain_since": null,
  "is_verified": true,
  "verification_count": 12,
  "no_show_count": 0,
  "activities_created_count": 8,
  "activities_attended_count": 34,
  "created_at": "2023-01-15T10:30:00Z",
  "last_seen_at": "2024-11-13T09:15:00Z",
  "interests": [
    {"tag": "hiking", "weight": 1.0},
    {"tag": "photography", "weight": 0.8}
  ],
  "settings": {
    "email_notifications": true,
    "push_notifications": true,
    "activity_reminders": true,
    "community_updates": true,
    "friend_requests": true,
    "marketing_emails": false,
    "ghost_mode": false,
    "language": "en",
    "timezone": "Europe/Amsterdam"
  }
}
```

**Stored Procedure**: `sp_get_user_profile(p_user_id, p_requesting_user_id)`
- Extract user_id from JWT `sub` claim
- Pass same user_id for both parameters (viewing own profile)

**Error Responses**:
- 401 Unauthorized: Invalid/expired token
- 404 Not Found: User no longer exists

---

### GET /users/{user_id}
**Description**: Get another user's public profile

**Authentication**: Required (JWT)

**Rate Limit**: 100/minute

**Path Parameters**:
- `user_id` (UUID, required): User ID to retrieve

**Request**:
- Headers: `Authorization: Bearer <token>`
- Body: None

**Response 200 OK**:
```json
{
  "user_id": "660e8400-e29b-41d4-a716-446655440000",
  "username": "janedoe",
  "first_name": "Jane",
  "last_name": "Doe",
  "profile_description": "Marathon runner and tech enthusiast",
  "main_photo_url": "https://cdn.example.com/photos/jane_main.jpg",
  "main_photo_moderation_status": "approved",
  "profile_photos_extra": [
    "https://cdn.example.com/photos/jane1.jpg"
  ],
  "gender": "female",
  "is_verified": true,
  "verification_count": 25,
  "activities_created_count": 15,
  "activities_attended_count": 67,
  "created_at": "2022-08-20T14:00:00Z",
  "interests": [
    {"tag": "running", "weight": 1.0},
    {"tag": "technology", "weight": 0.9}
  ]
}
```

**Note**: Sensitive fields NOT returned (email, date_of_birth, subscription details, settings, no_show_count)

**Stored Procedure**: `sp_get_user_profile(p_user_id, p_requesting_user_id)`
- p_user_id = path parameter
- p_requesting_user_id = JWT user_id

**Side Effects**:
- If requesting user has `ghost_mode=false`, create profile_view record
- If requesting user has `ghost_mode=true`, skip profile_view creation

**Error Responses**:
- 401 Unauthorized: Invalid/expired token
- 404 Not Found: User not found or blocked

**Blocking Logic**:
- If either user has blocked the other, return 404 (not revealing block existence)

---

### PATCH /users/me
**Description**: Update current user's profile

**Authentication**: Required (JWT)

**Rate Limit**: 20/minute

**Request Body** (all fields optional):
```json
{
  "first_name": "John",
  "last_name": "Doe",
  "profile_description": "Updated bio text",
  "date_of_birth": "1990-05-15",
  "gender": "male"
}
```

**Validations**:
- first_name: max 100 chars
- last_name: max 100 chars
- profile_description: max 5000 chars
- date_of_birth: ISO 8601 date, must be at least 18 years ago
- gender: max 50 chars

**Response 200 OK**:
```json
{
  "success": true,
  "updated_at": "2024-11-13T10:30:00Z"
}
```

**Stored Procedure**: `sp_update_user_profile(p_user_id, p_first_name, p_last_name, p_profile_description, p_date_of_birth, p_gender)`
- Extract user_id from JWT
- Pass NULL for fields not in request body

**Error Responses**:
- 400 Bad Request: Validation error (age < 18, field too long)
- 401 Unauthorized: Invalid token
- 403 Forbidden: User banned

---

### PATCH /users/me/username
**Description**: Change username

**Authentication**: Required (JWT)

**Rate Limit**: 3/hour

**Request Body**:
```json
{
  "new_username": "newusername123"
}
```

**Validations**:
- Length: 3-30 characters
- Format: alphanumeric + underscore only (regex: `^[a-zA-Z0-9_]{3,30}$`)
- Case insensitive uniqueness check

**Response 200 OK**:
```json
{
  "success": true,
  "username": "newusername123"
}
```

**Stored Procedure**: `sp_update_username(p_user_id, p_new_username)`

**Error Responses**:
- 400 Bad Request: Invalid format
- 401 Unauthorized: Invalid token
- 409 Conflict: Username already taken

---

### DELETE /users/me
**Description**: Delete user account (soft delete)

**Authentication**: Required (JWT)

**Rate Limit**: 1/hour

**Request Body**:
```json
{
  "password": "current_password",
  "confirmation": "DELETE MY ACCOUNT"
}
```

**Validations**:
- Password must match current password (verify via auth-api)
- Confirmation must be exact string "DELETE MY ACCOUNT"

**Response 200 OK**:
```json
{
  "success": true,
  "message": "Account deleted successfully"
}
```

**Stored Procedure**: `sp_delete_user_account(p_user_id)`

**Flow**:
1. Validate password via auth-api internal endpoint
2. Call stored procedure to anonymize data
3. Invalidate all user tokens (blacklist in Redis)
4. Send confirmation email to deleted email

**Error Responses**:
- 400 Bad Request: Invalid confirmation text
- 401 Unauthorized: Invalid password
- 403 Forbidden: Account already deleted

---

## PHOTO MANAGEMENT

### POST /users/me/photos/main
**Description**: Set main profile photo

**Authentication**: Required (JWT)

**Rate Limit**: 10/hour

**Request Body**:
```json
{
  "photo_url": "https://cdn.example.com/uploaded/photo123.jpg"
}
```

**Validations**:
- photo_url: valid HTTPS URL, max 500 chars
- URL must be from image-api CDN domain

**Response 200 OK**:
```json
{
  "success": true,
  "main_photo_url": "https://cdn.example.com/uploaded/photo123.jpg",
  "moderation_status": "pending",
  "message": "Photo uploaded. Awaiting moderation approval."
}
```

**Stored Procedure**: `sp_set_main_photo(p_user_id, p_photo_url)`

**Flow**:
1. Validate URL format and domain
2. Call stored procedure (sets status to 'pending')
3. Return response
4. Moderation queue picks up pending photo

**Error Responses**:
- 400 Bad Request: Invalid URL
- 401 Unauthorized: Invalid token
- 413 Payload Too Large: File size exceeds limit (handled by image-api)

**Notes**:
- User must upload photo to image-api first, get CDN URL
- Main photo MUST show clear face (functional safety requirement)
- Moderation typically completes within 24 hours

---

### POST /users/me/photos
**Description**: Add photo to extra photos array

**Authentication**: Required (JWT)

**Rate Limit**: 20/hour

**Request Body**:
```json
{
  "photo_url": "https://cdn.example.com/uploaded/photo456.jpg"
}
```

**Validations**:
- photo_url: valid HTTPS URL, max 500 chars
- URL must be from image-api CDN domain
- Max 8 photos total (including main photo = 9 total, but extra array = 8)

**Response 200 OK**:
```json
{
  "success": true,
  "photo_count": 3,
  "profile_photos_extra": [
    "https://cdn.example.com/photos/1.jpg",
    "https://cdn.example.com/photos/2.jpg",
    "https://cdn.example.com/uploaded/photo456.jpg"
  ]
}
```

**Stored Procedure**: `sp_add_profile_photo(p_user_id, p_photo_url)`

**Error Responses**:
- 400 Bad Request: Invalid URL or max photos reached
- 401 Unauthorized: Invalid token
- 409 Conflict: Photo already in array

---

### DELETE /users/me/photos
**Description**: Remove photo from extra photos array

**Authentication**: Required (JWT)

**Rate Limit**: 20/hour

**Request Body**:
```json
{
  "photo_url": "https://cdn.example.com/photos/1.jpg"
}
```

**Response 200 OK**:
```json
{
  "success": true,
  "photo_count": 2,
  "profile_photos_extra": [
    "https://cdn.example.com/photos/2.jpg",
    "https://cdn.example.com/uploaded/photo456.jpg"
  ]
}
```

**Stored Procedure**: `sp_remove_profile_photo(p_user_id, p_photo_url)`

**Error Responses**:
- 400 Bad Request: Photo not found in array
- 401 Unauthorized: Invalid token

---

## INTEREST TAGS

### GET /users/me/interests
**Description**: Get current user's interests

**Authentication**: Required (JWT)

**Rate Limit**: 100/minute

**Response 200 OK**:
```json
{
  "interests": [
    {"tag": "hiking", "weight": 1.0},
    {"tag": "photography", "weight": 0.8},
    {"tag": "coffee", "weight": 0.6}
  ],
  "count": 3
}
```

**Implementation**: Included in `sp_get_user_profile()` response

**Error Responses**:
- 401 Unauthorized: Invalid token

---

### PUT /users/me/interests
**Description**: Replace all interests (bulk update)

**Authentication**: Required (JWT)

**Rate Limit**: 10/minute

**Request Body**:
```json
{
  "interests": [
    {"tag": "hiking", "weight": 1.0},
    {"tag": "photography", "weight": 0.8},
    {"tag": "coffee", "weight": 0.6}
  ]
}
```

**Validations**:
- Max 20 interests
- Each tag: alphanumeric + spaces, max 100 chars
- Each weight: 0.0-1.0 range
- Unique tags

**Response 200 OK**:
```json
{
  "success": true,
  "interest_count": 3,
  "interests": [
    {"tag": "hiking", "weight": 1.0},
    {"tag": "photography", "weight": 0.8},
    {"tag": "coffee", "weight": 0.6}
  ]
}
```

**Stored Procedure**: `sp_set_user_interests(p_user_id, p_interests)`

**Error Responses**:
- 400 Bad Request: Validation error (too many tags, invalid weight)
- 401 Unauthorized: Invalid token

---

### POST /users/me/interests
**Description**: Add single interest

**Authentication**: Required (JWT)

**Rate Limit**: 30/minute

**Request Body**:
```json
{
  "tag": "running",
  "weight": 0.9
}
```

**Validations**:
- tag: alphanumeric + spaces, max 100 chars
- weight: 0.0-1.0 range (default 1.0 if omitted)

**Response 200 OK**:
```json
{
  "success": true,
  "message": "Interest added successfully"
}
```

**Stored Procedure**: `sp_add_user_interest(p_user_id, p_interest_tag, p_weight)`

**Error Responses**:
- 400 Bad Request: Max interests reached (20) or invalid tag/weight
- 401 Unauthorized: Invalid token

---

### DELETE /users/me/interests/{tag}
**Description**: Remove single interest

**Authentication**: Required (JWT)

**Rate Limit**: 30/minute

**Path Parameters**:
- `tag` (string, required): Interest tag to remove

**Response 200 OK**:
```json
{
  "success": true,
  "message": "Interest removed successfully"
}
```

**Stored Procedure**: `sp_remove_user_interest(p_user_id, p_interest_tag)`

**Error Responses**:
- 401 Unauthorized: Invalid token
- 404 Not Found: Interest not found (still returns 200 for idempotency)

---

## USER SETTINGS

### GET /users/me/settings
**Description**: Get current user's settings

**Authentication**: Required (JWT)

**Rate Limit**: 100/minute

**Response 200 OK**:
```json
{
  "email_notifications": true,
  "push_notifications": true,
  "activity_reminders": true,
  "community_updates": true,
  "friend_requests": true,
  "marketing_emails": false,
  "ghost_mode": false,
  "language": "en",
  "timezone": "Europe/Amsterdam"
}
```

**Stored Procedure**: `sp_get_user_settings(p_user_id)`

**Error Responses**:
- 401 Unauthorized: Invalid token

**Notes**:
- If settings don't exist, creates default settings first

---

### PATCH /users/me/settings
**Description**: Update user settings (partial update)

**Authentication**: Required (JWT)

**Rate Limit**: 20/minute

**Request Body** (all fields optional):
```json
{
  "email_notifications": false,
  "push_notifications": true,
  "ghost_mode": true,
  "language": "nl",
  "timezone": "Europe/Berlin"
}
```

**Validations**:
- Booleans: true/false
- language: ISO 639-1 code (2 chars)
- timezone: IANA timezone string
- ghost_mode: requires Premium subscription

**Response 200 OK**:
```json
{
  "success": true,
  "settings": {
    "email_notifications": false,
    "push_notifications": true,
    "activity_reminders": true,
    "community_updates": true,
    "friend_requests": true,
    "marketing_emails": false,
    "ghost_mode": true,
    "language": "nl",
    "timezone": "Europe/Berlin"
  }
}
```

**Stored Procedure**: `sp_update_user_settings(p_user_id, ...all_settings_params)`

**Error Responses**:
- 400 Bad Request: Invalid timezone or language code
- 401 Unauthorized: Invalid token
- 403 Forbidden: Ghost mode requested but not Premium subscriber

**Premium Feature Gate**:
```python
if request.ghost_mode is not None and request.ghost_mode == True:
    if jwt_payload["subscription_level"] != "premium":
        raise HTTPException(403, "Ghost mode requires Premium subscription")
```

---

## SUBSCRIPTION MANAGEMENT

### GET /users/me/subscription
**Description**: Get current subscription details

**Authentication**: Required (JWT)

**Rate Limit**: 100/minute

**Response 200 OK**:
```json
{
  "subscription_level": "premium",
  "subscription_expires_at": "2025-12-31T23:59:59Z",
  "is_captain": false,
  "days_remaining": 412
}
```

**Implementation**: Extract from users table

**Error Responses**:
- 401 Unauthorized: Invalid token

---

### POST /users/me/subscription
**Description**: Update subscription (admin or payment processor only)

**Authentication**: Required (JWT + admin role or payment processor API key)

**Rate Limit**: 10/minute

**Request Body**:
```json
{
  "subscription_level": "premium",
  "subscription_expires_at": "2025-12-31T23:59:59Z"
}
```

**Validations**:
- subscription_level: free/club/premium
- subscription_expires_at: required for club/premium, NULL for free
- Must be future date

**Response 200 OK**:
```json
{
  "success": true,
  "subscription_level": "premium",
  "subscription_expires_at": "2025-12-31T23:59:59Z"
}
```

**Stored Procedure**: `sp_update_subscription(p_user_id, p_subscription_level, p_subscription_expires_at)`

**Error Responses**:
- 400 Bad Request: Invalid level/expiry combination
- 401 Unauthorized: Invalid token
- 403 Forbidden: Not admin or payment processor

**Authorization Logic**:
```python
if not (jwt_payload.get("role") == "admin" or request.headers.get("X-Payment-API-Key") == PAYMENT_API_KEY):
    raise HTTPException(403, "Unauthorized")
```

---

## CAPTAIN PROGRAM

### POST /users/{user_id}/captain
**Description**: Grant Captain status (admin only)

**Authentication**: Required (JWT + admin role)

**Rate Limit**: 10/minute

**Path Parameters**:
- `user_id` (UUID, required): User to grant Captain status

**Request Body**:
```json
{
  "is_captain": true
}
```

**Response 200 OK**:
```json
{
  "success": true,
  "user_id": "550e8400-e29b-41d4-a716-446655440000",
  "is_captain": true,
  "captain_since": "2024-11-13T10:00:00Z",
  "subscription_level": "premium",
  "subscription_expires_at": "2025-11-13T10:00:00Z"
}
```

**Stored Procedure**: `sp_set_captain_status(p_user_id, p_is_captain)`

**Error Responses**:
- 401 Unauthorized: Invalid token
- 403 Forbidden: Not admin
- 404 Not Found: User not found

**Authorization Check**:
```python
if jwt_payload.get("role") != "admin":
    raise HTTPException(403, "Admin access required")
```

---

### DELETE /users/{user_id}/captain
**Description**: Revoke Captain status (admin only)

**Authentication**: Required (JWT + admin role)

**Rate Limit**: 10/minute

**Path Parameters**:
- `user_id` (UUID, required): User to revoke Captain status

**Response 200 OK**:
```json
{
  "success": true,
  "user_id": "550e8400-e29b-41d4-a716-446655440000",
  "is_captain": false,
  "subscription_level": "free"
}
```

**Stored Procedure**: `sp_set_captain_status(p_user_id, FALSE)`

**Error Responses**:
- 401 Unauthorized: Invalid token
- 403 Forbidden: Not admin
- 404 Not Found: User not found

---

## TRUST & VERIFICATION

### GET /users/me/verification
**Description**: Get verification and trust metrics

**Authentication**: Required (JWT)

**Rate Limit**: 100/minute

**Response 200 OK**:
```json
{
  "verification_count": 12,
  "no_show_count": 0,
  "is_verified": true,
  "trust_score": 95.5,
  "activities_attended_count": 34
}
```

**Implementation**: Extract from users table + calculate trust_score

**Trust Score Calculation**:
```
trust_score = min(100, (verification_count * 10) - (no_show_count * 20) + (activities_attended_count * 0.5))
```

**Error Responses**:
- 401 Unauthorized: Invalid token

---

### POST /users/{user_id}/verify
**Description**: Internal endpoint - increment verification count (called by Participation API after peer verification)

**Authentication**: Required (Service-to-Service API key)

**Rate Limit**: 1000/minute

**Path Parameters**:
- `user_id` (UUID, required): User to verify

**Headers**:
- `X-Service-API-Key`: Service authentication key

**Response 200 OK**:
```json
{
  "success": true,
  "new_verification_count": 13
}
```

**Stored Procedure**: `sp_increment_verification_count(p_user_id)`

**Error Responses**:
- 401 Unauthorized: Invalid service key
- 404 Not Found: User not found

**Authorization**:
```python
if request.headers.get("X-Service-API-Key") != SERVICE_API_KEY:
    raise HTTPException(401, "Invalid service key")
```

---

### POST /users/{user_id}/no-show
**Description**: Internal endpoint - increment no-show count (called by Moderation API after confirmed no-show report)

**Authentication**: Required (Service-to-Service API key)

**Rate Limit**: 1000/minute

**Path Parameters**:
- `user_id` (UUID, required): User with no-show

**Headers**:
- `X-Service-API-Key`: Service authentication key

**Response 200 OK**:
```json
{
  "success": true,
  "new_no_show_count": 1,
  "warning": "User now has 1 no-show. Threshold for automatic ban is 5."
}
```

**Stored Procedure**: `sp_increment_no_show_count(p_user_id)`

**Side Effects**:
- If no_show_count >= 5: Send warning email
- If no_show_count >= 10: Automatic temporary ban (7 days)

**Error Responses**:
- 401 Unauthorized: Invalid service key
- 404 Not Found: User not found

---

## ACTIVITY COUNTERS

### POST /users/{user_id}/activity-counters
**Description**: Internal endpoint - update activity counters (called by Activities API)

**Authentication**: Required (Service-to-Service API key)

**Rate Limit**: 1000/minute

**Path Parameters**:
- `user_id` (UUID, required): User to update

**Headers**:
- `X-Service-API-Key`: Service authentication key

**Request Body**:
```json
{
  "created_delta": 1,
  "attended_delta": 0
}
```

**Validations**:
- created_delta: integer (-100 to 100)
- attended_delta: integer (-100 to 100)

**Response 200 OK**:
```json
{
  "success": true,
  "activities_created_count": 9,
  "activities_attended_count": 34
}
```

**Stored Procedure**: `sp_update_activity_counts(p_user_id, p_created_delta, p_attended_delta)`

**Error Responses**:
- 400 Bad Request: Delta would make counter negative
- 401 Unauthorized: Invalid service key
- 404 Not Found: User not found

---

## USER SEARCH

### GET /users/search
**Description**: Search users by name or username

**Authentication**: Required (JWT)

**Rate Limit**: 30/minute

**Query Parameters**:
- `q` (string, required): Search query (min 2 chars)
- `limit` (int, optional): Max results (default 20, max 100)
- `offset` (int, optional): Pagination offset (default 0)

**Example Request**:
```
GET /users/search?q=john&limit=20&offset=0
```

**Response 200 OK**:
```json
{
  "results": [
    {
      "user_id": "550e8400-e29b-41d4-a716-446655440000",
      "username": "johndoe",
      "first_name": "John",
      "last_name": "Doe",
      "main_photo_url": "https://cdn.example.com/photos/john.jpg",
      "is_verified": true,
      "verification_count": 12
    },
    {
      "user_id": "660e8400-e29b-41d4-a716-446655440000",
      "username": "johnsmith",
      "first_name": "John",
      "last_name": "Smith",
      "main_photo_url": "https://cdn.example.com/photos/smith.jpg",
      "is_verified": false,
      "verification_count": 3
    }
  ],
  "total": 2,
  "limit": 20,
  "offset": 0
}
```

**Stored Procedure**: `sp_search_users(p_query, p_requesting_user_id, p_limit, p_offset)`

**Blocking Filter**:
- Excludes users where blocking exists (either direction)
- Excludes banned users
- Does not reveal blocking status

**Error Responses**:
- 400 Bad Request: Query too short (< 2 chars)
- 401 Unauthorized: Invalid token

---

## LAST SEEN TRACKING

### POST /users/me/heartbeat
**Description**: Update last seen timestamp (called periodically by client)

**Authentication**: Required (JWT)

**Rate Limit**: 12/hour (once per 5 minutes)

**Request Body**: None (empty)

**Response 200 OK**:
```json
{
  "success": true,
  "last_seen_at": "2024-11-13T10:45:00Z"
}
```

**Stored Procedure**: `sp_update_last_seen(p_user_id)`

**Error Responses**:
- 401 Unauthorized: Invalid token

**Implementation Notes**:
- Client should call this every 5 minutes while app is active
- Used for "last seen" indicators in user lists
- Low priority - can be debounced on client side

---

## MODERATION ENDPOINTS (Admin Only)

### GET /admin/users/photo-moderation
**Description**: Get pending main photo moderations

**Authentication**: Required (JWT + moderator/admin role)

**Rate Limit**: 100/minute

**Query Parameters**:
- `limit` (int, optional): Max results (default 50, max 200)
- `offset` (int, optional): Pagination offset (default 0)

**Response 200 OK**:
```json
{
  "results": [
    {
      "user_id": "550e8400-e29b-41d4-a716-446655440000",
      "username": "johndoe",
      "email": "john@example.com",
      "main_photo_url": "https://cdn.example.com/photos/pending123.jpg",
      "created_at": "2024-11-13T09:00:00Z"
    }
  ],
  "total": 1,
  "limit": 50,
  "offset": 0
}
```

**Stored Procedure**: `sp_get_pending_photo_moderations(p_limit, p_offset)`

**Authorization Check**:
```python
if jwt_payload.get("role") not in ["admin", "moderator"]:
    raise HTTPException(403, "Moderator access required")
```

**Error Responses**:
- 401 Unauthorized: Invalid token
- 403 Forbidden: Not moderator/admin

---

### POST /admin/users/{user_id}/photo-moderation
**Description**: Approve or reject main photo

**Authentication**: Required (JWT + moderator/admin role)

**Rate Limit**: 100/minute

**Path Parameters**:
- `user_id` (UUID, required): User whose photo to moderate

**Request Body**:
```json
{
  "status": "approved"
}
```

**Validations**:
- status: "approved" or "rejected"

**Response 200 OK**:
```json
{
  "success": true,
  "user_id": "550e8400-e29b-41d4-a716-446655440000",
  "moderation_status": "approved"
}
```

**Stored Procedure**: `sp_moderate_main_photo(p_user_id, p_moderation_status, p_moderator_user_id)`

**Side Effects**:
- If rejected: Send email notification to user via email-api
- Update main_photo_moderation_status

**Error Responses**:
- 400 Bad Request: Invalid status
- 401 Unauthorized: Invalid token
- 403 Forbidden: Not moderator/admin
- 404 Not Found: User not found

---

### POST /admin/users/{user_id}/ban
**Description**: Ban user (temporary or permanent)

**Authentication**: Required (JWT + admin role)

**Rate Limit**: 10/minute

**Path Parameters**:
- `user_id` (UUID, required): User to ban

**Request Body**:
```json
{
  "reason": "Repeated no-shows and harassment reports",
  "expires_at": "2024-12-13T00:00:00Z"
}
```

**Validations**:
- reason: required, max 1000 chars
- expires_at: optional (NULL = permanent ban), must be future date

**Response 200 OK**:
```json
{
  "success": true,
  "user_id": "550e8400-e29b-41d4-a716-446655440000",
  "status": "temporary_ban",
  "ban_reason": "Repeated no-shows and harassment reports",
  "ban_expires_at": "2024-12-13T00:00:00Z"
}
```

**Stored Procedure**: `sp_ban_user(p_user_id, p_ban_reason, p_ban_expires_at)`

**Side Effects**:
- Send ban notification email via email-api
- Invalidate all user tokens (blacklist in Redis)
- Remove from all activities (via Activities API webhook)

**Error Responses**:
- 400 Bad Request: Invalid expiry date (past date)
- 401 Unauthorized: Invalid token
- 403 Forbidden: Not admin
- 404 Not Found: User not found

**Authorization Check**:
```python
if jwt_payload.get("role") != "admin":
    raise HTTPException(403, "Admin access required")
```

---

### DELETE /admin/users/{user_id}/ban
**Description**: Unban user

**Authentication**: Required (JWT + admin role)

**Rate Limit**: 10/minute

**Path Parameters**:
- `user_id` (UUID, required): User to unban

**Response 200 OK**:
```json
{
  "success": true,
  "user_id": "550e8400-e29b-41d4-a716-446655440000",
  "status": "active"
}
```

**Stored Procedure**: `sp_unban_user(p_user_id)`

**Side Effects**:
- Send unban notification email via email-api

**Error Responses**:
- 401 Unauthorized: Invalid token
- 403 Forbidden: Not admin
- 404 Not Found: User not found

---

## ðŸ”§ ERROR HANDLING SPECIFICATION

### Standard Error Response Format

All errors follow this JSON structure:

```json
{
  "error": {
    "code": "ERROR_CODE",
    "message": "Human-readable error message",
    "details": {
      "field": "additional context"
    }
  }
}
```

### HTTP Status Codes

**2xx Success**:
- 200 OK: Successful GET/PATCH/DELETE
- 201 Created: Successful POST (rare in this API)

**4xx Client Errors**:
- 400 Bad Request: Validation error, invalid input
- 401 Unauthorized: Missing/invalid/expired token
- 403 Forbidden: Valid token but insufficient permissions
- 404 Not Found: Resource not found or blocked
- 409 Conflict: Duplicate resource (username taken, photo already added)
- 413 Payload Too Large: File size exceeded (photos)
- 422 Unprocessable Entity: Semantic validation error
- 429 Too Many Requests: Rate limit exceeded

**5xx Server Errors**:
- 500 Internal Server Error: Database error, unexpected exception
- 503 Service Unavailable: Database connection failed

### Error Code Catalog

**Authentication Errors (AUTH_***)**:
- AUTH_TOKEN_MISSING: No Authorization header
- AUTH_TOKEN_INVALID: Invalid JWT signature or format
- AUTH_TOKEN_EXPIRED: Token past expiration time
- AUTH_INSUFFICIENT_PERMISSIONS: Valid token but wrong role

**Validation Errors (VALIDATION_***)**:
- VALIDATION_FIELD_REQUIRED: Required field missing
- VALIDATION_FIELD_TOO_LONG: Field exceeds max length
- VALIDATION_FIELD_TOO_SHORT: Field below min length
- VALIDATION_INVALID_FORMAT: Field format invalid (email, UUID, etc.)
- VALIDATION_INVALID_VALUE: Value not in allowed set
- VALIDATION_AGE_RESTRICTION: User under 18 years old

**Resource Errors (RESOURCE_***)**:
- RESOURCE_NOT_FOUND: User/resource doesn't exist
- RESOURCE_BLOCKED: User blocked by/blocking target
- RESOURCE_DUPLICATE: Duplicate username, photo already added
- RESOURCE_LIMIT_EXCEEDED: Max interests (20), photos (8) reached

**Subscription Errors (SUBSCRIPTION_***)**:
- SUBSCRIPTION_REQUIRED: Feature requires paid subscription
- SUBSCRIPTION_PREMIUM_REQUIRED: Feature requires Premium level
- SUBSCRIPTION_EXPIRED: Subscription has expired

**Moderation Errors (MODERATION_***)**:
- MODERATION_PHOTO_PENDING: Main photo awaiting approval
- MODERATION_PHOTO_REJECTED: Main photo was rejected

**User Status Errors (USER_***)**:
- USER_BANNED: Account permanently banned
- USER_TEMPORARILY_BANNED: Account temporarily banned
- USER_NOT_VERIFIED: Email not verified (rare in this API)
- USER_DELETED: Account has been deleted

### Error Response Examples

**401 Unauthorized - Token Expired**:
```json
{
  "error": {
    "code": "AUTH_TOKEN_EXPIRED",
    "message": "Access token has expired",
    "details": {
      "expired_at": "2024-11-13T10:30:00Z"
    }
  }
}
```

**403 Forbidden - Premium Required**:
```json
{
  "error": {
    "code": "SUBSCRIPTION_PREMIUM_REQUIRED",
    "message": "Ghost mode requires Premium subscription",
    "details": {
      "current_level": "free",
      "required_level": "premium",
      "upgrade_url": "/subscription/upgrade"
    }
  }
}
```

**404 Not Found - User Blocked**:
```json
{
  "error": {
    "code": "RESOURCE_NOT_FOUND",
    "message": "User not found"
  }
}
```
Note: Same response for both "doesn't exist" and "blocked" to prevent block enumeration

**409 Conflict - Username Taken**:
```json
{
  "error": {
    "code": "RESOURCE_DUPLICATE",
    "message": "Username already taken",
    "details": {
      "field": "username",
      "value": "johndoe"
    }
  }
}
```

**422 Validation Error - Age Restriction**:
```json
{
  "error": {
    "code": "VALIDATION_AGE_RESTRICTION",
    "message": "User must be at least 18 years old",
    "details": {
      "field": "date_of_birth",
      "min_age": 18,
      "provided_age": 16
    }
  }
}
```

**429 Rate Limit Exceeded**:
```json
{
  "error": {
    "code": "RATE_LIMIT_EXCEEDED",
    "message": "Too many requests. Please try again later.",
    "details": {
      "retry_after": 300,
      "limit": "3/hour",
      "endpoint": "/users/me/username"
    }
  }
}
```

**500 Internal Server Error - Database**:
```json
{
  "error": {
    "code": "DATABASE_ERROR",
    "message": "An unexpected error occurred. Please try again.",
    "details": {
      "request_id": "550e8400-e29b-41d4-a716-446655440000"
    }
  }
}
```

### Error Handling Logic in API

**Token Validation**:
```python
try:
    payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
    user_id = payload["sub"]
    subscription_level = payload.get("subscription_level", "free")
except jwt.ExpiredSignatureError:
    raise HTTPException(401, {
        "code": "AUTH_TOKEN_EXPIRED",
        "message": "Access token has expired",
        "details": {"expired_at": datetime.utcnow().isoformat()}
    })
except jwt.InvalidTokenError:
    raise HTTPException(401, {
        "code": "AUTH_TOKEN_INVALID",
        "message": "Invalid access token"
    })
```

**Stored Procedure Error Handling**:
```python
try:
    result = db.execute(sp_get_user_profile(user_id, requesting_user_id))
    if result is None:
        raise HTTPException(404, {
            "code": "RESOURCE_NOT_FOUND",
            "message": "User not found"
        })
except psycopg2.IntegrityError as e:
    raise HTTPException(409, {
        "code": "RESOURCE_DUPLICATE",
        "message": str(e)
    })
except psycopg2.Error as e:
    logger.error(f"Database error: {e}")
    raise HTTPException(500, {
        "code": "DATABASE_ERROR",
        "message": "An unexpected error occurred. Please try again.",
        "details": {"request_id": request_id}
    })
```

**Subscription Gate**:
```python
def require_premium(jwt_payload: dict):
    if jwt_payload.get("subscription_level") != "premium":
        raise HTTPException(403, {
            "code": "SUBSCRIPTION_PREMIUM_REQUIRED",
            "message": "This feature requires Premium subscription",
            "details": {
                "current_level": jwt_payload.get("subscription_level", "free"),
                "required_level": "premium",
                "upgrade_url": "/subscription/upgrade"
            }
        })
```

**Rate Limit Error**:
```python
from slowapi.errors import RateLimitExceeded

@app.exception_handler(RateLimitExceeded)
async def rate_limit_handler(request: Request, exc: RateLimitExceeded):
    return JSONResponse(
        status_code=429,
        content={
            "error": {
                "code": "RATE_LIMIT_EXCEEDED",
                "message": "Too many requests. Please try again later.",
                "details": {
                    "retry_after": 300,
                    "limit": str(exc.detail),
                    "endpoint": request.url.path
                }
            }
        }
    )
```

---

## ðŸ”’ SECURITY CONSIDERATIONS

### Token Validation
- ALWAYS validate JWT signature using HS256
- Check expiration timestamp (`exp` claim)
- Extract user_id from `sub` claim
- Never trust user_id from request body if token present

### Subscription Level Enforcement
- Premium features MUST check `subscription_level` from token
- Ghost mode: Premium only
- See who favorited/viewed you: Premium only
- Always return 403 with clear message when feature gated

### Blocking Privacy
- When user is blocked/blocking, return 404 (not 403)
- Never reveal blocking status in error messages
- Stored procedures handle blocking logic, API just returns 404

### Photo Moderation
- Main photo always requires moderation (functional safety)
- Extra photos do NOT require moderation
- Users with pending/rejected main photos can still use platform

### Rate Limiting
- Aggressive limits on username change (3/hour), account deletion (1/hour)
- Standard limits on profile updates (20/min)
- High limits on read operations (100/min)
- Redis-based rate limiting with slowapi

### Service-to-Service Authentication
- Internal endpoints use `X-Service-API-Key` header
- Different key per service (Activities API, Participation API, etc.)
- Keys stored in environment variables
- Never exposed to clients

### GDPR Compliance
- Account deletion anonymizes data (soft delete)
- Preserves activity participation history (for other users)
- User can request full data export (future endpoint)
- Privacy settings control notification types

---

## ðŸ“Š PERFORMANCE CONSIDERATIONS

### Database Indexing
Ensure these indexes exist (from schema):
- `idx_users_email` - Username/email lookups
- `idx_users_subscription` - Subscription filtering
- `idx_users_main_photo_moderation` - Moderation queue
- `idx_user_interests_tag` - Interest matching
- `idx_user_settings_ghost_mode` - Ghost mode queries

### Caching Strategy
**Redis Cache Keys**:
- `user_profile:{user_id}` - Complete profile (TTL: 5 minutes)
- `user_settings:{user_id}` - User settings (TTL: 30 minutes)
- `user_interests:{user_id}` - Interest list (TTL: 1 hour)

**Cache Invalidation**:
- Profile updates â†’ invalidate `user_profile:{user_id}`
- Settings updates â†’ invalidate `user_settings:{user_id}`
- Interest changes â†’ invalidate `user_interests:{user_id}`
- Photo changes â†’ invalidate `user_profile:{user_id}`

**Implementation**:
```python
async def get_user_profile_cached(user_id: UUID) -> dict:
    cache_key = f"user_profile:{user_id}"
    cached = redis.get(cache_key)
    if cached:
        return json.loads(cached)
    
    # Call stored procedure
    profile = db.execute(sp_get_user_profile(user_id, user_id))
    
    # Cache for 5 minutes
    redis.setex(cache_key, 300, json.dumps(profile))
    return profile
```

### Query Optimization
- Use stored procedures (pre-compiled, optimized)
- Avoid N+1 queries (interests/settings joined in sp_get_user_profile)
- Pagination on search endpoints (limit + offset)
- Filter banned users in stored procedures (not API layer)

---

## ðŸ§ª TESTING STRATEGY

### Unit Tests (per endpoint)
- Token validation (valid, expired, invalid, missing)
- Request validation (missing fields, invalid formats, too long)
- Subscription gates (free trying premium features)
- Stored procedure calls (correct parameters)
- Error handling (database errors, not found, conflicts)

### Integration Tests
- Full registration â†’ profile update flow
- Photo upload â†’ moderation â†’ approval flow
- Subscription upgrade â†’ premium features enabled
- Ban user â†’ all tokens invalidated
- Account deletion â†’ data anonymized

### Load Tests
- 100 concurrent profile reads
- 50 concurrent profile updates
- Search endpoint with pagination
- Rate limit enforcement

### Security Tests
- JWT tampering detection
- Subscription level bypass attempts
- Blocking enumeration attacks
- Service API key validation
- SQL injection (via stored procedures)

---

## ðŸ“ˆ MONITORING & METRICS

### Key Metrics to Track
**Performance**:
- Endpoint response times (p50, p95, p99)
- Database query times
- Cache hit rate
- Rate limit hit rate

**Business**:
- User registrations per day
- Subscription conversions (free â†’ club â†’ premium)
- Photo moderation queue size
- Average verification count per user
- Ban rate

**Errors**:
- 4xx error rate by endpoint
- 5xx error rate by endpoint
- Database connection errors
- Token validation failures

### Logging
**Info Level**:
- User profile viewed (user_id, viewed_user_id, ghost_mode)
- Subscription updated (user_id, old_level, new_level)
- Captain status changed (user_id, is_captain)
- Photo moderation action (user_id, status, moderator_id)

**Warning Level**:
- Rate limit exceeded (user_id, endpoint, limit)
- Premium feature attempted by free user (user_id, feature)
- Blocked user access attempt (blocker_id, blocked_id)

**Error Level**:
- Database connection failed
- Stored procedure exception
- JWT validation error (invalid signature)
- Service API key invalid

---

## ðŸš€ DEPLOYMENT NOTES

### Environment Variables
```bash
# Database
DATABASE_URL=postgresql://user:pass@localhost:5432/activity
DATABASE_POOL_SIZE=20

# Redis
REDIS_URL=redis://localhost:6379/0

# JWT
JWT_SECRET_KEY=your-secret-key-here
JWT_ALGORITHM=HS256

# Service API Keys
ACTIVITIES_API_KEY=activities-service-key
PARTICIPATION_API_KEY=participation-service-key
MODERATION_API_KEY=moderation-service-key
PAYMENT_API_KEY=payment-processor-key

# External Services
IMAGE_API_URL=http://image-api:8001
EMAIL_API_URL=http://email-api:8002

# Rate Limiting
RATE_LIMIT_STORAGE=redis://localhost:6379/1

# Monitoring
SENTRY_DSN=https://...@sentry.io/...
```

### Health Check Endpoint
```
GET /health
Response: {"status": "ok", "database": "connected", "redis": "connected"}
```

### Database Migration
- Run schema creation script first
- Create all stored procedures
- Verify indexes exist
- Test stored procedures with sample data

---

## ðŸ“ SUMMARY CHECKLIST

**For AI Code Agent - Verify Implementation**:

âœ… **Stored Procedures Created** (23 total):
- [ ] sp_get_user_profile
- [ ] sp_update_user_profile
- [ ] sp_update_username
- [ ] sp_set_main_photo
- [ ] sp_add_profile_photo
- [ ] sp_remove_profile_photo
- [ ] sp_set_user_interests
- [ ] sp_add_user_interest
- [ ] sp_remove_user_interest
- [ ] sp_get_user_settings
- [ ] sp_update_user_settings
- [ ] sp_update_subscription
- [ ] sp_set_captain_status
- [ ] sp_increment_verification_count
- [ ] sp_increment_no_show_count
- [ ] sp_update_activity_counts
- [ ] sp_update_last_seen
- [ ] sp_search_users
- [ ] sp_ban_user
- [ ] sp_unban_user
- [ ] sp_moderate_main_photo
- [ ] sp_get_pending_photo_moderations
- [ ] sp_delete_user_account

âœ… **API Endpoints Implemented** (28 total):
- [ ] GET /users/me
- [ ] GET /users/{user_id}
- [ ] PATCH /users/me
- [ ] PATCH /users/me/username
- [ ] DELETE /users/me
- [ ] POST /users/me/photos/main
- [ ] POST /users/me/photos
- [ ] DELETE /users/me/photos
- [ ] GET /users/me/interests
- [ ] PUT /users/me/interests
- [ ] POST /users/me/interests
- [ ] DELETE /users/me/interests/{tag}
- [ ] GET /users/me/settings
- [ ] PATCH /users/me/settings
- [ ] GET /users/me/subscription
- [ ] POST /users/me/subscription
- [ ] POST /users/{user_id}/captain
- [ ] DELETE /users/{user_id}/captain
- [ ] GET /users/me/verification
- [ ] POST /users/{user_id}/verify (internal)
- [ ] POST /users/{user_id}/no-show (internal)
- [ ] POST /users/{user_id}/activity-counters (internal)
- [ ] GET /users/search
- [ ] POST /users/me/heartbeat
- [ ] GET /admin/users/photo-moderation
- [ ] POST /admin/users/{user_id}/photo-moderation
- [ ] POST /admin/users/{user_id}/ban
- [ ] DELETE /admin/users/{user_id}/ban

âœ… **Security Implemented**:
- [ ] JWT token validation on all protected endpoints
- [ ] Subscription level enforcement
- [ ] Service-to-service API key auth
- [ ] Rate limiting per endpoint
- [ ] Blocking privacy (404 instead of 403)
- [ ] Admin/moderator role checks

âœ… **External Integrations**:
- [ ] image-api for photo uploads
- [ ] email-api for notifications
- [ ] auth-api for password validation

âœ… **Error Handling**:
- [ ] Standard error response format
- [ ] All error codes defined
- [ ] Appropriate HTTP status codes
- [ ] User-friendly error messages

âœ… **Performance**:
- [ ] Redis caching implemented
- [ ] Cache invalidation on updates
- [ ] Database indexes verified
- [ ] Pagination on list endpoints

âœ… **Monitoring**:
- [ ] Logging at appropriate levels
- [ ] Key metrics tracked
- [ ] Health check endpoint

---

**END OF SPECIFICATION**

This document provides complete specifications for building the User Profile API. All endpoint-to-stored-procedure mappings are explicit. All error conditions are documented. All security considerations are outlined. Ready for AI code generation.
